/**
 ******************************************************************************
 * @file           : spi_cmd_master_slave.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f407xx.h>
#include "software_delay.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
/*
    PB14 (SPI2_MISO)
    PB15 (SPI2_MOSI)
    PB13 (SPI2_SCK)
    PA4  (SPI2_NSS)
*/

/*
 * Command definitions for SPI communication
 */
#define COMMAND_LED_CTRL        0x50
#define COMMAND_SENSOR_READ     0x51
#define COMMAND_LED_READ        0x52
#define COMMAND_PRINT           0x53
#define COMMAND_ID_READ         0x54

/*
 * LED control commands
 */
#define LED_ON                   1
#define LED_OFF                  0

/*
 * Analog pin definitions
 */
#define ANALOG_PIN0              0
#define ANALOG_PIN1              1
#define ANALOG_PIN2              2
#define ANALOG_PIN3              3
#define ANALOG_PIN4              4

#define LED_PIN                  9
#define ACK_BYTE                 0xF5

void SPI2_GPIO_Init(void)
{
    GPIO_Handle_t spiPIN;
    spiPIN.pGPIOx = GPIOB;
    spiPIN.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    spiPIN.GPIO_PinConfig.GPIO_PinAltFunMode = 5; // AF5 for SPI2
    spiPIN.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    spiPIN.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    spiPIN.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

    // SCLK
    spiPIN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
    GPIO_Init(&spiPIN);

    // MOSI
    spiPIN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
    GPIO_Init(&spiPIN);

    // MISO
    spiPIN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
    GPIO_Init(&spiPIN);

    // NSS
    spiPIN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_12;
    GPIO_Init(&spiPIN);
}

void SPI2_Init(SPI_Handle_t *pSPI2Handle)
{
    // Initialize SPI2 data
    pSPI2Handle->pSPIx = SPI2;
    pSPI2Handle->SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
    pSPI2Handle->SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FULLDUPLEX;
    pSPI2Handle->SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV2;
    pSPI2Handle->SPIConfig.SPI_DFF = SPI_DFF_8BITS;
    pSPI2Handle->SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
    pSPI2Handle->SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
    pSPI2Handle->SPIConfig.SPI_SSM = SPI_SSM_EN;


    // Hardware initialization
    SPI_HWInit(pSPI2Handle);
}

void GPIO_Button_Init(GPIO_Handle_t *pButtonHandle)
{
    GPIO_Config(pButtonHandle, GPIOA, GPIO_PIN_NO_0, GPIO_MODE_IN, GPIO_SPEED_FAST, GPIO_OP_TYPE_OD, GPIO_NO_PUPD, 0);
    GPIO_Init(pButtonHandle);
}

uint8_t SPIResp_Verification(uint8_t ack_data)
{
    if (ack_data == ACK_BYTE)
    {
        return 1; // Acknowledged
    }
    return 0; // Not acknowledged
}

int main(void)
{
	GPIO_Handle_t button;
    SPI_Handle_t *pSPI2Handle = calloc(1, sizeof(SPI_Handle_t));
    uint8_t commandcode = COMMAND_LED_CTRL;
    uint8_t ack_data = 0x00;
    uint8_t dummy_write_data = 0xFF;
    uint8_t dummy_read_data = 0x00;
    uint8_t arg_cmd_au8[2] = {LED_PIN, LED_ON};



    // Initialize GPIO and SPI for SPI2
	SPI2_GPIO_Init();
    SPI2_Init(pSPI2Handle);

    GPIO_Button_Init(&button);

    /* Loop forever */
	while(1)
	{
        while (!GPIO_ReadFromInputPin(GPIOA, GPIO_PIN_NO_0)); // wait for button press
        SoftwareDelay(200); // delay 200 ticks
        SPI_PeripheralControl(pSPI2Handle, ENABLE);
        // Send command code
        SPI_SendData(pSPI2Handle, &commandcode, 1);
        // Receive to clear off RXNE after sending the command code
        SPI_ReceiveData(pSPI2Handle, &dummy_read_data, 1);
        // Send dummy data to fetch the ACK response from slave (shift register)
        SPI_SendData(pSPI2Handle, &dummy_write_data, 1);
        // Reception the ack byte
        SPI_ReceiveData(pSPI2Handle, &ack_data, 1);
        // Verify the ack byte
        if (SPIResp_Verification(ack_data)) // if acknowledged
        {
            // Send a LED ON command
            SPI_SendData(pSPI2Handle, &arg_cmd_au8, 2);
        }
        else
        {
            // Handle NACK scenario (optional)
        }
        // Wait until SPI is not busy
        while (SPI_GETFLAGSTATUS(pSPI2Handle, SPI_BUSY_FLAG));
        // Disable the SPI peripheral
        SPI_PeripheralControl(pSPI2Handle, DISABLE);
	}
}
