/**
 ******************************************************************************
 * @file           : spi_cmd_master_slave.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f407xx.h>
#include "software_delay.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
/*
    STM32F407 Discovery Board
    PB14 (SPI2_MISO)
    PB15 (SPI2_MOSI)
    PB13 (SPI2_SCK)
    PB12 (SPI2_NSS)
*/

/*
    ESP32 Slave
    GPIO19 (SPI2_MISO)
    GPIO23 (SPI2_MOSI)
    GPIO18 (SPI2_SCK)
    GPIO5  (SPI2_NSS)
*/



void SPI2_GPIO_Init(void)
{
    GPIO_Handle_t spiPIN;
    spiPIN.pGPIOx = GPIOB;
    spiPIN.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    spiPIN.GPIO_PinConfig.GPIO_PinAltFunMode = 5; // AF5 for SPI2
    spiPIN.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    spiPIN.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    spiPIN.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;

    // SCLK
    spiPIN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
    GPIO_Init(&spiPIN);

    // MOSI
    spiPIN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
    GPIO_Init(&spiPIN);

    /* MISO
    spiPIN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
    GPIO_Init(&spiPIN);
    */

    // NSS
    spiPIN.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_12;
    GPIO_Init(&spiPIN);
}

void SPI2_Init(SPI_Handle_t *pSPI2Handle)
{
    // Initialize SPI2 data
    pSPI2Handle->pSPIx = SPI2;
    pSPI2Handle->SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
    pSPI2Handle->SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FULLDUPLEX;
    pSPI2Handle->SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV32; // 2MHz
    pSPI2Handle->SPIConfig.SPI_DFF = SPI_DFF_8BITS;
    pSPI2Handle->SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
    pSPI2Handle->SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
    pSPI2Handle->SPIConfig.SPI_SSM = SPI_SSM_DI; // HW slave management


    // Hardware initialization
    SPI_HWInit(pSPI2Handle);
}

void GPIO_Button_Init(GPIO_Handle_t *pButtonHandle)
{
    GPIO_Config(pButtonHandle, GPIOA, GPIO_PIN_NO_0, GPIO_MODE_IN, GPIO_SPEED_FAST, GPIO_OP_TYPE_OD, GPIO_NO_PUPD, 0);
    GPIO_Init(pButtonHandle);
    // Enable clock for button GPIO port
    GPIO_PeriClockControl(pButtonHandle->pGPIOx, ENABLE);
}


int main(void)
{
    // Initialize variables
    GPIO_Handle_t button;
    SPI_Handle_t *pSPI2Handle = calloc(1, sizeof(SPI_Handle_t));
    uint8_t master_data[] = {1,2,3,4,5};
    uint8_t length = sizeof(master_data);

    // Initialize GPIO pin and SPI for SPI2
    SPI2_GPIO_Init();
    SPI2_Init(pSPI2Handle);
    /*
	* making SSOE 1 does NSS output enable.
	* The NSS pin is automatically managed by the hardware.
	* i.e when SPE=1 , NSS will be pulled to low
	* and NSS pin will be high when SPE=0
	*/
    SPI_SSOEConfig(pSPI2Handle, ENABLE); // Enable SSOE for NSS pin management

    // Initialize button GPIO
    GPIO_Button_Init(&button);


    /* Loop forever */
	while(1)
    {
        // Wait until button is pressed
        while (!GPIO_ReadFromInputPin(button.pGPIOx, button.GPIO_PinConfig.GPIO_PinNumber));
        SoftwareDelay(300); // Debounce delay
        // Enable SPI2 peripheral
        SPI_PeripheralControl(pSPI2Handle, ENABLE);
        // Send data to slave
        SPI_SendData(pSPI2Handle, master_data, sizeof(master_data));
        // Wait until SPI is not busy
        while (SPI_GETFLAGSTATUS(pSPI2Handle->pSPIx->SR, SPI_BUSY_FLAG));
        // Disable the SPI peripheral
        SPI_PeripheralControl(pSPI2Handle, DISABLE);
        // Wait until button is released
        while (GPIO_ReadFromInputPin(button.pGPIOx, button.GPIO_PinConfig.GPIO_PinNumber));
        SoftwareDelay(300); // Debounce delay
    }
}
